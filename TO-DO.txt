################ FATTO, RICONTROLLARE ################
 
- Quando l'azione va in errore, la selector deve riprendersi il lifecycle id nello state movie/tv-lifecycle
- Scroll infinito quando non ci sono media in lista
- Scroll infinito solo verticale
- LIFECYCLEENUM COME CRUD CONDITION ENUM
- Clean error eliminare azione e reducer, attendo per capire se possano essere utili
- tipizzare valore ritorno reducer
- Genre List/Languages/Certifications valorizzazione in app initializer
- Error notification
- Success notification
- refractor inject with method (anche i destroy ref)
- Refractor action, chiavi pi√π comprensibili, ogni action con la feature, quindi per movie-lifecycle esempio, 1 crud per discovery, 1 per search, 1 per lifecycle list
- generalizzare navigator (usabile per header e sotto route come movie lifecycle)
- ogni failure ha la sua action di failure (search movie failure, discovery movie failure, create lifecycle failure, update lifecycle failure ecc..)
- tipizzazioni a any da elimiare

################ GENERIC ################
- CAMBIARE NOME APP, MOVIE BOOKMARK.... MEDIA BOOKMARK
- Refractor index models export
- Spinner loading e disattivare roba
- [Violation] 'setTimeout' handler took 345ms
- Eliminare zorro (auth, altro cercare)
- Proxy con action supabase per nascondere chiave API
- html semantico
- aria accessibility
- i18e (anche date filter) + label tutte in un file json
- check for change detection on push
- Gestione timeout
- Spinner async
- Card e altri componenti con grandezze placeholder mentre aspettano dati async per evitare cambi dimensione
- Refractor interfaccie, stato confuso, separazione dto entity non ordinato
- Nelle subcribe custom next e error
- Label lifecycle sul card component
- Abount / credit con logo tmdb+ footer con testo di api appartenenza a tmdb
- Hai dimenticato alcune destroyed ref...
- aria accessibility
- oggetti placeholder dove ci sono dati asincroni
- astratta tra discovery.filter.directive e lifecycle.filter.directive
- lifecycle rinominare in bookmark
- initSubscription ovunque
-ricerca automatica per i discovery (?)
-range date filter validatori error 

################ DUBBIO, FORSE NO ################
- notificator come stato globale (D:\WEB-DEVELOPER\Portfolio-personale\projects-showcase\movie-bookmark-root\backup\notificator)
- http interceptor e/o handling error generalizzato con log (log service)
- sintassi semplificata con rxjs and ngrx, no return e graffe
- tv_data movie_data, decoupling da fare

################ AUTH ################

- Utente in sessione e utente in stato potrebbero essere non sincronizzati (es 2 tab, su una faccio logout, cancello local storage, sull'altra stato ngrx ha ancora dati utente)
quindi pushare l'utente nei reducer da sessione (da verificare)

- Test form input/accessibility etc.;

-Login
    - Test flow;
    - Forgot Password
        - Password Reset capcta
    - Validators;
    - Refractor form builder

-Register
    - User already registered(?);
    - Validators;
    - Verification message + landing page;
    - Test flow;
    - Register success flow + mail + style
    - Refractor form builder



################ DISCOVERY FILTERS ################
  - Certifications i18e, servizio filters 


################ Search Filter ################
  - Validators and control on search digit (number, symbol, length...) 
  - Refractor to angular material

################ MOVIE DETAILS ################

- Sanificazione elementi null nella risposta
- Se img non presente, caricare img placeholder
- Clean detail nello stato in destroy





################ HANDLING ERRORS ################

- Clean Error generic, only one time;
- Alert/popup errors detail generic;
<app-form-error [errors]="authSelectError$ | async"></app-form-error>
  authSelectError$: Observable<ErrorResponse | null> = this.store.select(
    AuthSelectors.selectError
  );

################ LAZY LOAD ################

- Immagini media-item card

################ CACHING ################











  isMovieEntity(
    entityMediaLifeCycle: object
  ): entityMediaLifeCycle is Movie_Life_Cycle {
    return (entityMediaLifeCycle as Movie_Life_Cycle).movie_id !== undefined;
  }





          // let caseResult:number = this.supabaseUtilsService.checkCase(
          //   movieLifecycleFromDB,
          //   movieLifecycleDTO
          // )
          //  return this.CUSTOM[1]({movieLifecycleDTO, user})
  // readonly CUSTOM = {
  //   0: (params: { movieLifecycleDTO: MediaLifecycleDTO; user: User }) => {
  //     let { movieLifecycleDTO, user } = params;
  //     return this.supabaseMovieLifecycleDAO.createMovieLifeCycle(
  //       movieLifecycleDTO.lifecycleEnum,
  //       movieLifecycleDTO.mediaId,
  //       user
  //     );
  //   },
  //   1: (params: {
  //     movieLifecycleDTO: MediaLifecycleDTO;
  //     user: User;
  //   }): Observable<Movie_Life_Cycle[]> => {
  //     let { movieLifecycleDTO } = params;
  //     return this.supabaseMovieLifecycleDAO.deleteMovieLifeCycle(
  //       movieLifecycleDTO.mediaId,
  //       movieLifecycleDTO.lifecycleEnum
  //     );
  //   },
  //   2: (movieLifecycleDTO: MediaLifecycleDTO) => {
  //     return this.supabaseMovieLifecycleDAO.updateMovieLifeCycle(
  //       movieLifecycleDTO.lifecycleEnum,
  //       movieLifecycleDTO.mediaId
  //     );
  //   },
  //   3: (movieLifecycleDTO: MediaLifecycleDTO) => {
  //     let movieLifecycleFromDBCustom: Movie_Life_Cycle = {
  //       lifecycleId: 0,
  //       movie_id: movieLifecycleDTO.mediaId,
  //     };
  //     return of([movieLifecycleFromDBCustom]);
  //   },
  //   99: () => {
  //     throw new Error('Something went wrong. Case 99'); //to-do traccia errore su db, anche se impossibile che passi qui
  //   },
  // };



  
  private readonly COND_MOVIE: {
    [key: number]: (props: any) => Observable<Movie_Life_Cycle[]>;
  } = {
    0: (props: any) => {
      return this.supabaseMovieLifecycleDAO.createMovieLifeCycle(
        props.lifecycleEnum,
        props.mediaId,
        props.user
      );
    },
    1: (props: any) => {
      return this.supabaseMovieLifecycleDAO.deleteMovieLifeCycle(
        props.lifecycleEnum,
        props.mediaId
      );
    },
    2: (props: any) => {
      return this.supabaseMovieLifecycleDAO.updateMovieLifeCycle(
        props.lifecycleEnum,
        props.mediaId
      );
    },
    3: (props: any) => {
      return of([props.movieLifecycleFromDBCustom]);
    },
    99: (props: any) => {
      throw new Error('Something went wrong. Case -99');
    },
  };


    // createOrUpdateOrDeleteMovieLifecycle(
  //   movieLifecycleDTO: MediaLifecycleDTO,
  //   user: User,
  //   movieLifecycleMap: MediaLifecycleMap
  // ): Observable<MediaLifecycleMap> {
  //   return this.supabaseMovieLifecycleDAO
  //     .findLifecycleListByMovieIds([movieLifecycleDTO.mediaId])
  //     .pipe(
  //       switchMap((movieLifecycleFromDB: Movie_Life_Cycle[]) => {
  //         let c = this.supabaseUtilsService.checkCase(
  //           movieLifecycleFromDB,
  //           movieLifecycleDTO
  //         );
  //         return this.COND_MOVIE[c]({
  //           lifecycleEnum: movieLifecycleDTO.lifecycleEnum,
  //           mediaId: movieLifecycleDTO.mediaId,
  //           user: user,
  //           movieLifecycleFromDBCustom: {
  //             lifecycleId: 0,
  //             movie_id: movieLifecycleDTO.mediaId,
  //             user_id: user.id,
  //           },
  //         });

  //       }),
  //       map((movieMovieLifecycle: Movie_Life_Cycle[]) => {
  //         return this.supabaseUtilsService.injectInMovieLifecycleMap(
  //           movieMovieLifecycle,
  //           movieLifecycleMap
  //         );
  //       })
  //     );
  // }

            let c: number = this.supabaseUtilsService.checkCase(
            tvLifecycleFromDB,
            tvLifecycleDTO
          );

          if (c === 0) {
            return this.supabaseTVLifecycleDAO.createTVLifeCycle(
              tvLifecycleDTO.lifecycleEnum,
              tvLifecycleDTO.mediaId,
              user
            );
          } else if (c === 1) {
            return this.supabaseTVLifecycleDAO.deleteTVLifeCycle(
              tvLifecycleDTO.mediaId,
              tvLifecycleDTO.lifecycleEnum
            );
          } else if (c === 2) {
            return this.supabaseTVLifecycleDAO.updateTVLifeCycle(
              tvLifecycleDTO.lifecycleEnum,
              tvLifecycleDTO.mediaId
            );
          } else if (c === 3) {
            let tvLifecycleFromDBCustom: TV_Life_Cycle = {
              lifecycleId: 0,
              tv_id: tvLifecycleDTO.mediaId,
              user_id: user.id,
            };
            return of([tvLifecycleFromDBCustom]);
          } else {
            throw new Error('Something went wrong. Case -99');
          }