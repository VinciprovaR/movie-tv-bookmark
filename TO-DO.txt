################ IGNORATO ################
 
- i18e (anche date filter) + label tutte in un file json (?)


################ FATTO, RICONTROLLARE ################
 
- Quando l'azione va in errore, la selector deve riprendersi il lifecycle id nello state movie/tv-lifecycle
- Scroll infinito quando non ci sono media in lista
- Scroll infinito solo verticale
- LIFECYCLEENUM COME CRUD CONDITION ENUM
- Clean error eliminare azione e reducer, attendo per capire se possano essere utili
- tipizzare valore ritorno reducer
- Genre List/Languages/Certifications valorizzazione in app initializer
- Error notification
- Success notification
- refractor inject with method (anche i destroy ref)
- Refractor action, chiavi più comprensibili, ogni action con la feature, quindi per movie-lifecycle esempio, 1 crud per discovery, 1 per search, 1 per lifecycle list
- generalizzare navigator (usabile per header e sotto route come movie lifecycle)
- ogni failure ha la sua action di failure (search movie failure, discovery movie failure, create lifecycle failure, update lifecycle failure ecc..)
- tipizzazioni a any da elimiare
- Card e altri componenti con grandezze placeholder mentre aspettano dati async per evitare cambi dimensione
- check http://localhost:4200/#/person-detail/1964445

################ GENERIC ################
- CAMBIARE NOME APP, MOVIE BOOKMARK.... MEDIA BOOKMARK
- Refractor index models export
- Spinner loading async disattivare roba
- [Violation] 'setTimeout' handler took 345ms
- Eliminare zorro (auth, altro cercare)
- Proxy con action supabase per nascondere chiave API
- html semantico
- aria accessibility

- alert stile
- Gestione timeout chiamate
- Refractor interfaccie, stato confuso, separazione dto entity non ordinato
- Nelle subcribe custom next e error

- Abount / credit con logo tmdb+ sezione info con testo di api appartenenza a tmdb
- Hai dimenticato alcune destroyed ref...
- aria accessibility
- oggetti placeholder dove ci sono dati asincroni
- astratta tra discovery.filter.directive e lifecycle.filter.directive
- lifecycle rinominare in bookmark
- initSubscription ovunque (?)
- ricerca automatica per i discovery (?)
- range date filter validatori error 
- via tutti gli item prima di card 
- card con titoli particolari escono fuori card, guardare tipo http://localhost:4200/#/person-detail/3295424
- scroll infinito anche per i media lifecycle (bookmark)
- far funzionare bene 1x 2x immagini
- immagini placeholder da cambiare + su smarthphone sono troppo piccole
- header giu su dopo n y scroll
- troppi chunk al primo atterraggio
- click fuori chiude sub menu header mobile
- check for @defer
- tutto ciò che è in hidden con css @if non renderizzato
- Largest Contentful Paint (LCP) error, check
- stile globale refractor
- card search e discovery in orizzontale su smarthphone
- media deteail usare solo mediaData
- media detail append_to_response per chiamate in sequenza
- domsanitizer tutta app
- Video not found handler
- Media detail assenza di cast, crew, video... sezioni condizionali
- hover card e altri, lieve colore
- fallback if img not found...
- dialog video max-height cell orizzontale
- separazione membri classe  come in videos-container.components
- refractor ref on destroy, instance tipo renderer, subscription, ecc. (destro ref potresti usare una classe astratta per tutti i componenti)
- integrare AbstractComponent (arrivato a movie discovery da sopra a sotto)
- integrare On push strategy
- verificare componenti che hanno bisogno di astratta, tipo movie discovery e tv discovery
- scrollbar cast crew container detail diventa troppo piccola
- identificare tutto ciò che potrebbe avere troppi item (esempio cast crew, cobra 11 ha più di 2000 membri del cast portando la tab a 1,4 GB di memoria) controllare
  iterazioni, tutte, e porre un limite massimo
  - fade scroller controllare per change detection
-check class hidden-container, strano comportamento 
- credit sotto categorie per crew
- vedere se riesci a eliminare if els from route store in movie and tv detail credits
- mouseover header change detection
- tutti i campi, if else palceholder
- tv credits movie credits, singolo componente
- tutti i component  change detection on push, tutti i punti che hanno bisogno di detect change aggiungere metodo
- refractor astrazione, ricominciare da tutti, suddividere per features e creare le astrazioni mancanti (discovery, search, bookmark per esempio)
- Stesso discorso per i servizi 
-person movie e tv per crew eliminare quelli già presenti 
- page not found
- person detail, read more solo esplosione se testo più lungo di tot
- search additional check if no additional store allora non triggerare evento
- 

################ DUBBIO, FORSE NO ################
- notificator come stato globale (D:\WEB-DEVELOPER\Portfolio-personale\projects-showcase\movie-bookmark-root\backup\notificator)
- http interceptor e/o handling error generalizzato con log (log service)
- sintassi semplificata con rxjs and ngrx, no return e graffe
- tv_data movie_data, decoupling da fare

################ AUTH ################

- Utente in sessione e utente in stato potrebbero essere non sincronizzati (es 2 tab, su una faccio logout, cancello local storage, sull'altra stato ngrx ha ancora dati utente)
quindi pushare l'utente nei reducer da sessione (da verificare)

- Test form input/accessibility etc.;

-Login
    - Test flow;
    - Forgot Password
        - Password Reset capcta
    - Validators;
    - Refractor form builder

-Register
    - User already registered(?);
    - Validators;
    - Verification message + landing page;
    - Test flow;
    - Register success flow + mail + style
    - Refractor form builder



################ DISCOVERY FILTERS ################
  - Certifications i18e, servizio filters 


################ Search Filter ################
  - Validators and control on search digit (number, symbol, length...) 
  - Refractor to angular material

################ MOVIE DETAILS ################

- Sanificazione elementi null nella risposta
- Se img non presente, caricare img placeholder
- Clean detail nello stato in destroy





################ HANDLING ERRORS ################

- Clean Error generic, only one time;
- Alert/popup errors detail generic;
<app-form-error [errors]="authSelectError$ | async"></app-form-error>
  authSelectError$: Observable<ErrorResponse | null> = this.store.select(
    AuthSelectors.selectError
  );

################ LAZY LOAD ################

- Immagini media-item card

################ CACHING ################











  isMovieEntity(
    entityMediaLifeCycle: object
  ): entityMediaLifeCycle is Movie_Life_Cycle {
    return (entityMediaLifeCycle as Movie_Life_Cycle).movie_id !== undefined;
  }





          // let caseResult:number = this.supabaseUtilsService.checkCase(
          //   movieLifecycleFromDB,
          //   movieLifecycleDTO
          // )
          //  return this.CUSTOM[1]({movieLifecycleDTO, user})
  // readonly CUSTOM = {
  //   0: (params: { movieLifecycleDTO: MediaLifecycleDTO; user: User }) => {
  //     let { movieLifecycleDTO, user } = params;
  //     return this.supabaseMovieLifecycleDAO.createMovieLifeCycle(
  //       movieLifecycleDTO.lifecycleEnum,
  //       movieLifecycleDTO.mediaId,
  //       user
  //     );
  //   },
  //   1: (params: {
  //     movieLifecycleDTO: MediaLifecycleDTO;
  //     user: User;
  //   }): Observable<Movie_Life_Cycle[]> => {
  //     let { movieLifecycleDTO } = params;
  //     return this.supabaseMovieLifecycleDAO.deleteMovieLifeCycle(
  //       movieLifecycleDTO.mediaId,
  //       movieLifecycleDTO.lifecycleEnum
  //     );
  //   },
  //   2: (movieLifecycleDTO: MediaLifecycleDTO) => {
  //     return this.supabaseMovieLifecycleDAO.updateMovieLifeCycle(
  //       movieLifecycleDTO.lifecycleEnum,
  //       movieLifecycleDTO.mediaId
  //     );
  //   },
  //   3: (movieLifecycleDTO: MediaLifecycleDTO) => {
  //     let movieLifecycleFromDBCustom: Movie_Life_Cycle = {
  //       lifecycleId: 0,
  //       movie_id: movieLifecycleDTO.mediaId,
  //     };
  //     return of([movieLifecycleFromDBCustom]);
  //   },
  //   99: () => {
  //     throw new Error('Something went wrong. Case 99'); //to-do traccia errore su db, anche se impossibile che passi qui
  //   },
  // };



  
  private readonly COND_MOVIE: {
    [key: number]: (props: any) => Observable<Movie_Life_Cycle[]>;
  } = {
    0: (props: any) => {
      return this.supabaseMovieLifecycleDAO.createMovieLifeCycle(
        props.lifecycleEnum,
        props.mediaId,
        props.user
      );
    },
    1: (props: any) => {
      return this.supabaseMovieLifecycleDAO.deleteMovieLifeCycle(
        props.lifecycleEnum,
        props.mediaId
      );
    },
    2: (props: any) => {
      return this.supabaseMovieLifecycleDAO.updateMovieLifeCycle(
        props.lifecycleEnum,
        props.mediaId
      );
    },
    3: (props: any) => {
      return of([props.movieLifecycleFromDBCustom]);
    },
    99: (props: any) => {
      throw new Error('Something went wrong. Case -99');
    },
  };


    // createOrUpdateOrDeleteMovieLifecycle(
  //   movieLifecycleDTO: MediaLifecycleDTO,
  //   user: User,
  //   movieLifecycleMap: MediaLifecycleMap
  // ): Observable<MediaLifecycleMap> {
  //   return this.supabaseMovieLifecycleDAO
  //     .findLifecycleListByMovieIds([movieLifecycleDTO.mediaId])
  //     .pipe(
  //       switchMap((movieLifecycleFromDB: Movie_Life_Cycle[]) => {
  //         let c = this.supabaseUtilsService.checkCase(
  //           movieLifecycleFromDB,
  //           movieLifecycleDTO
  //         );
  //         return this.COND_MOVIE[c]({
  //           lifecycleEnum: movieLifecycleDTO.lifecycleEnum,
  //           mediaId: movieLifecycleDTO.mediaId,
  //           user: user,
  //           movieLifecycleFromDBCustom: {
  //             lifecycleId: 0,
  //             movie_id: movieLifecycleDTO.mediaId,
  //             user_id: user.id,
  //           },
  //         });

  //       }),
  //       map((movieMovieLifecycle: Movie_Life_Cycle[]) => {
  //         return this.supabaseUtilsService.injectInMovieLifecycleMap(
  //           movieMovieLifecycle,
  //           movieLifecycleMap
  //         );
  //       })
  //     );
  // }

            let c: number = this.supabaseUtilsService.checkCase(
            tvLifecycleFromDB,
            tvLifecycleDTO
          );

          if (c === 0) {
            return this.supabaseTVLifecycleDAO.createTVLifeCycle(
              tvLifecycleDTO.lifecycleEnum,
              tvLifecycleDTO.mediaId,
              user
            );
          } else if (c === 1) {
            return this.supabaseTVLifecycleDAO.deleteTVLifeCycle(
              tvLifecycleDTO.mediaId,
              tvLifecycleDTO.lifecycleEnum
            );
          } else if (c === 2) {
            return this.supabaseTVLifecycleDAO.updateTVLifeCycle(
              tvLifecycleDTO.lifecycleEnum,
              tvLifecycleDTO.mediaId
            );
          } else if (c === 3) {
            let tvLifecycleFromDBCustom: TV_Life_Cycle = {
              lifecycleId: 0,
              tv_id: tvLifecycleDTO.mediaId,
              user_id: user.id,
            };
            return of([tvLifecycleFromDBCustom]);
          } else {
            throw new Error('Something went wrong. Case -99');
          }